-- Aetherius Engine v4.0 | Proactive Performance & Resource Core
local Aetherius = {}

do
	local RunService = game:GetService("RunService")
	local Players = game:GetService("Players")
	local Workspace = game:GetService("Workspace")
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local CollectionService = game:GetService("CollectionService")
	local Stats = game:GetService("Stats")
	local Lighting = game:GetService("Lighting")
	local ContentProvider = game:GetService("ContentProvider")
	local UserSettings = UserSettings()
	local GameSettings = UserSettings:GetService("UserGameSettings")

	local Camera = Workspace.CurrentCamera
	local os_clock, table_insert, table_remove, math_floor, math_huge, math_exp, math_min, math_max, ipairs, pcall, task_spawn, task_wait, coroutine_create, coroutine_resume, coroutine_yield = os.clock, table.insert, table.remove, math.floor, math.huge, math.exp, math.min, math.max, ipairs, pcall, task.spawn, task.wait, coroutine.create, coroutine.resume, coroutine.yield

	Aetherius.Orchestrator = {
		PROFILES = {[1]={f=120,p=60,m=2000},[2]={f=60,p=55,m=1200},[3]={f=40,p=35,m=800},[4]={f=25,p=20,m=400}},
		_aggression = {render=1,physics=1,effects=1,core=1,resource=1},
		_fpsHistory = {}, _totalDeltaTime = 0, _historyIndex = 1, _lastCheck = 0,
		_isCalibrated = false, _emergencyState = false, _avgDelta = 1/60,
	}
	function Aetherius.Orchestrator:GetAverageFPS() local c=#self._fpsHistory; return if c>0 then c/self._totalDeltaTime else 120 end
	function Aetherius.Orchestrator:EnterEmergencyState() if self._emergencyState then return end; self._emergencyState=true; for k,_ in pairs(self._aggression) do self._aggression[k]=4 end; task.delay(2,function() self._emergencyState=false end) end
	function Aetherius.Orchestrator:AnalyzeAndAdjust()
		if not self._isCalibrated or self._emergencyState then return end
		local avgFps,realPhysicsFps,mem = self:GetAverageFPS(),Workspace:GetRealPhysicsFPS(),Stats.Total.Value
		local prof=self.PROFILES[4]; if avgFps>self.PROFILES[2].f then prof=self.PROFILES[1] elseif avgFps>self.PROFILES[3].f then prof=self.PROFILES[2] else prof=self.PROFILES[3] end
		local rs,ps,ms=avgFps/prof.f,realPhysicsFps/prof.p,prof.m/mem
		local nr,np,ne,nc,nres = if rs<0.9 then rs<0.7 and 3 or 2 else 1, if ps<0.9 then ps<0.7 and 4 or 3 else 1, if rs<1 or ms<1 then rs<0.8 or ms<0.8 and 4 or 3 else 1, prof==self.PROFILES[4] and 3 or prof==self.PROFILES[3] and 2 or 1, if ms<0.8 then 3 else 1
		local a=1-math_exp(-0.5*2); self._aggression.render=self._aggression.render+(nr-self._aggression.render)*a; self._aggression.physics=self._aggression.physics+(np-self._aggression.physics)*a; self._aggression.effects=self._aggression.effects+(ne-self._aggression.effects)*a; self._aggression.core=self._aggression.core+(nc-self._aggression.core)*a; self._aggression.resource=self._aggression.resource+(nres-self._aggression.resource)*a
		if nc>=3 and not self._potatoModeActive then self._potatoModeActive=true;Aetherius.CoreOptimizer:SetQualityLevel(1) elseif nc<2 and self._potatoModeActive then self._potatoModeActive=false;Aetherius.CoreOptimizer:RestoreQuality() end
	end
	function Aetherius.Orchestrator:Update(dt)
		if dt>self._avgDelta*3.5 and self._isCalibrated then self:EnterEmergencyState() end; self._avgDelta=self._avgDelta+(dt-self._avgDelta)*0.1
		local h,hs=#self._fpsHistory,60; if h<hs then table_insert(self._fpsHistory,dt);self._totalDeltaTime+=dt else self._totalDeltaTime=self._totalDeltaTime-self._fpsHistory[self._historyIndex]+dt;self._fpsHistory[self._historyIndex]=dt;self._historyIndex=(self._historyIndex%hs)+1 end
		local n=os_clock(); if n-self._lastCheck>0.5 then self:AnalyzeAndAdjust(); self._lastCheck=n end
	end

	Aetherius.Calibrator = {}
	function Aetherius.Calibrator:Run() task.wait(2); local d=10;local s,e={},os_clock();while os_clock()-e<d do table_insert(s,1/RunService.Heartbeat:Wait()) end; local function g(t) local n=0; for _,v in ipairs(t) do n+=v end;return n/#t end; local af=g(s);local o=Aetherius.Orchestrator;o.PROFILES[1].f=math_max(60,af*0.9);o.PROFILES[2].f=math_max(45,af*0.7);o.PROFILES[3].f=math_max(30,af*0.5);o._isCalibrated=true; end

	Aetherius.Scheduler = { _tasks={} }
	function Aetherius.Scheduler:AddTask(task) local co=coroutine_create(function() while true do pcall(task.fn); local a=Aetherius.Orchestrator._aggression[task.category] or 1; task_wait(task.baseInterval*a) end end); table_insert(self._tasks,co) end
	function Aetherius.Scheduler:Run() for _, co in ipairs(self._tasks) do coroutine_resume(co) end end

	Aetherius.SpatialGrid = { GRID_SIZE=250,_grid={},_tracked=setmetatable({},{__mode="k"})}
	function Aetherius.SpatialGrid:GetCell(p) local s=self.GRID_SIZE;return math_floor(p.X/s)..","..math_floor(p.Y/s)..","..math_floor(p.Z/s) end
	function Aetherius.SpatialGrid:Register(o,d) local c=self:GetCell(o.Position);self._grid[c]=self._grid[c] or {};table_insert(self._grid[c],o);self._tracked[o]={cell=c,data=d} end
	function Aetherius.SpatialGrid:GetNearby(p,r) local res,s,cr={},self.GRID_SIZE,math_floor(r/s)+1;local cx,cy,cz=math_floor(p.X/s),math_floor(p.Y/s),math_floor(p.Z/s);for i=cx-cr,cx+cr do for j=cy-cr,cy+cr do for k=cz-cr,cz+cr do local cell=self._grid[i..","..j..","..k];if cell then for _,o in ipairs(cell) do table_insert(res,o) end end end end end; return res end

	Aetherius.LODSystem = { DISTANCES_SQR={[1]={120^2,300^2,600^2},[2]={80^2,200^2,450^2},[3]={50^2,150^2,300^2}}, CULL_DELAY=5, _culled={} }
	function Aetherius.LODSystem:Register(m) if not m.PrimaryPart then return end; local p={};for _,d in ipairs(m:GetDescendants())do if d:IsA("BasePart")or d:IsA("Decal")then table_insert(p,d)end end;Aetherius.SpatialGrid:Register(m.PrimaryPart,{LOD={parts=p,lastFidelity=-1,lastTrans=-1,lastVisible=os_clock(),isCulled=false}}) end
	function Aetherius.LODSystem:Update(cam)
		local a=math_floor(Aetherius.Orchestrator._aggression.render+0.5);a=math_max(1,math_min(3,a));local levels=self.DISTANCES_SQR[a]
		local nearby=Aetherius.SpatialGrid:GetNearby(cam.Position,600)
		for _,part in ipairs(nearby) do
			local tracked=Aetherius.SpatialGrid._tracked[part]
			if not(part and part.Parent and tracked and tracked.data.LOD)or tracked.data.LOD.isCulled then continue end
			local _,inView=Camera:WorldToViewportPoint(part.Position); local entry,distSqr=tracked.data.LOD,(part.Position-cam.Position).MagnitudeSqr
			if inView then entry.lastVisible=os_clock() end
			local newTrans,newFid; if distSqr<levels[1] then newTrans,newFid=0,Enum.RenderFidelity.Precise elseif distSqr<levels[2] then newTrans,newFid=0.75,Enum.RenderFidelity.Automatic else newTrans,newFid=1,Enum.RenderFidelity.Performance end
			if entry.lastTrans~=newTrans then for _,p in ipairs(entry.parts)do if p:IsA("BasePart")then p.Transparency=newTrans end end;entry.lastTrans=newTrans end
			if entry.lastFidelity~=newFid then for _,p in ipairs(entry.parts)do if p:IsA("BasePart")then p.RenderFidelity=newFid end end;entry.lastFidelity=newFid end
			if distSqr>levels[3] and os_clock()-entry.lastVisible>self.CULL_DELAY and CollectionService:HasTag(part.Parent,"Cosmetic") then entry.isCulled=true;part.Parent.Parent=nil;table_insert(self._culled,{obj=part.Parent,pos=part.Position}) end
		end
	end
	function Aetherius.LODSystem:CheckCulled(camPos) for i=#self._culled,1,-1 do local c=self._culled[i];if(c.pos-camPos).Magnitude<500 then local tracked=Aetherius.SpatialGrid._tracked[c.obj.PrimaryPart];if tracked then tracked.data.LOD.isCulled=false;tracked.data.LOD.lastVisible=os_clock()end;c.obj.Parent=Workspace;table_remove(self._culled,i)end end end

	Aetherius.PhysicsGovernor = { DISTANCES_SQR={[1]=math_huge,[2]=250^2,[3]=150^2,[4]=80^2},SLEEP_VEL=0.4 }
	function Aetherius.PhysicsGovernor:Register(m) if not m.PrimaryPart then return end;local p={};for _,d in ipairs(m:GetDescendants())do if d:IsA("BasePart")and not d.Anchored then table_insert(p,d)end end;if #p>0 then Aetherius.SpatialGrid:Register(m.PrimaryPart,{Physics={parts=p}})end end
	function Aetherius.PhysicsGovernor:Update(camPos)
		local a=math_floor(Aetherius.Orchestrator._aggression.physics+0.5);a=math_max(1,math_min(4,a));local distSqr=self.DISTANCES_SQR[a]
		local nearby=Aetherius.SpatialGrid:GetNearby(camPos,500)
		for _,pPart in ipairs(nearby) do
			local tracked=Aetherius.SpatialGrid._tracked[pPart]
			if not(pPart and pPart.Parent and tracked and tracked.data.Physics)then continue end
			local shouldAnchor=(pPart.Position-camPos).MagnitudeSqr>distSqr or pPart.AssemblyLinearVelocity.Magnitude<self.SLEEP_VEL
			for _,part in ipairs(tracked.data.Physics)do if part and part.Anchored~=shouldAnchor then part.Anchored=shouldAnchor end end
		end
	end
	
	Aetherius.ResourceSentinel = { _assets={}, UNLOAD_TIME=120 }
	function Aetherius.ResourceSentinel:Track(assetId) self._assets[assetId]=os_clock() end
	function Aetherius.ResourceSentinel:Cleanup()
		local toUnload,now={},os_clock()
		for id,lastUsed in pairs(self._assets) do if now-lastUsed>self.UNLOAD_TIME*Aetherius.Orchestrator._aggression.resource then table_insert(toUnload,id);self._assets[id]=nil end end
		if #toUnload>0 then ContentProvider:UnloadAssets(toUnload) end
	end
	
	Aetherius.CoreOptimizer = {}
	function Aetherius.CoreOptimizer:SetQualityLevel(l) GameSettings.SavedQualityLevel=Enum.SavedQualitySetting["QualityLevel"..l];Lighting.Technology=Enum.Technology.Compatibility;Lighting.Shadows=false; end
	function Aetherius.CoreOptimizer:RestoreQuality() GameSettings.SavedQualityLevel=Enum.SavedQualitySetting.Automatic;Lighting.Technology=Enum.Technology.ShadowMap;Lighting.Shadows=true; end

	function Aetherius:Activate()
		task_spawn(self.Calibrator.Run)
		local function process(instances) for _,inst in ipairs(instances)do if not inst or not inst.PrimaryPart then continue end;if CollectionService:HasTag(inst,"ManagedRender")then self.LODSystem:Register(inst)end;if CollectionService:HasTag(inst,"ManagedPhysics")then self.PhysicsGovernor:Register(inst)end;task_wait()end end
		local initialBatch={};for _,t in ipairs({"ManagedRender","ManagedPhysics"})do for _,m in ipairs(CollectionService:GetTagged(t))do table_insert(initialBatch,m)end end;task_spawn(process,initialBatch)
		for _,t in ipairs({"ManagedRender","ManagedPhysics"})do CollectionService:GetInstanceAddedSignal(t):Connect(function(m) if t=="ManagedRender"then self.LODSystem:Register(m)else self.PhysicsGovernor:Register(m)end end)end
		local function trackSound(s) if s.SoundId~="" then self.ResourceSentinel:Track(s.SoundId) end; s.Played:Connect(function() self.ResourceSentinel:Track(s.SoundId) end) end
		local function trackImage(i) if i.Image~="" then self.ResourceSentinel:Track(i.Image) end; i:GetPropertyChangedSignal("Image"):Connect(function() self.ResourceSentinel:Track(i.Image) end) end
		Workspace.DescendantAdded:Connect(function(d) if d:IsA("Sound") then trackSound(d) elseif d:IsA("ImageLabel") or d:IsA("ImageButton") or d:IsA("Texture") then trackImage(d) end end)

		self.Scheduler:AddTask({name="Orchestrator",fn=function()self.Orchestrator:Update(RunService.Heartbeat:Wait())end,baseInterval=0,category="core"})
		self.Scheduler:AddTask({name="LOD",fn=function()self.LODSystem:Update(Camera.CFrame)end,baseInterval=0.1,category="render"})
		self.Scheduler:AddTask({name="Physics",fn=function()self.PhysicsGovernor:Update(Camera.CFrame.Position)end,baseInterval=0.2,category="physics"})
		self.Scheduler:AddTask({name="CulledCheck",fn=function()self.LODSystem:CheckCulled(Camera.CFrame.Position)end,baseInterval=1,category="render"})
		self.Scheduler:AddTask({name="Resources",fn=function()self.ResourceSentinel:Cleanup()end,baseInterval=15,category="resource"})
		self.Scheduler:Run()
	end
end

Aetherius:Activate()
